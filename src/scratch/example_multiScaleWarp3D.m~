function example_multiScaleWarp3D(PREBUCKNER_PATH, OUTPUT_PATH)
% example run of subject-to-subject multiscale warp.
% requires: OUTPUT_PATH, PREBUCKNER_PATH

    %% Set up run
    
    % parameters
    params.patchSize = [1, 1, 1] * 3; % patch size for comparing patches.
    params.gridSpacing = [1, 1, 1] * 3; % grid spacing
    params.searchSize = [1, 1, 1] * 3; % search region size. Note: >> local = (searchSize-1)/2.
    params.nScales = 4;
    params.nInnerReps = 2;
    params.volPad = [5, 5, 5];     
    
    opts.inferMethod = @UGM_Infer_LBP; % @UGM_Infer_LBP or @UGM_Infer_MF
    opts.warpDir = 'forward'; % 'backward' or 'forward'
    opts.warpReg = 'mrf'; % 'none' or 'mrf' or 'quilt'
    opts.verbose = 2; % 1 for simple, 2 for complex/debug
    opts.distanceMethod = 'stateDist'; % 'stateDist' or 'volknnsearch'
    opts.location = 0.01;
    
    % max data size along largest dimension
    opts.maxVolSize = 58;

    % files. TODO: should switch to registering to atlas
    paths.sourceFile = fullfile(PREBUCKNER_PATH, 'buckner02_brain_affinereg_to_b61.nii.gz');
    paths.targetFile = fullfile(PREBUCKNER_PATH, 'buckner03_brain_affinereg_to_b61.nii.gz');
    
    % segmentation files. Only really necessary for some quick visualization at the end.
    paths.sourceSegFile = fullfile(PREBUCKNER_PATH, 'buckner02_brain_affinereg_to_b61_seg.nii.gz');
    paths.targetSegFile = fullfile(PREBUCKNER_PATH, 'buckner03_brain_affinereg_to_b61_seg.nii.gz');
    
<<<<<<< HEAD
    %% Immediate Output Processing
    % This is just some quick visualization. Analysis should be done separately
    
    % compose the final image using the resulting displacements
    sourceWarped = volwarp(source, displ, opts.warpDir);
    targetWarped = volwarp(target, displ, 'backward');
    
    % TODO: try to do quilt instead of warp. Soemthing like:
    % [~, ~, srcgridsize] = patchlib.grid(size(source), patchSize, patchOverlap);
    % alternativeWarped = patchlib.quilt(qp, srcgridsize, patchSize, patchOverlap); 
    
    % display results
    if ndims(source) == 2 %#ok<ISMAT>
        patchview.figure();
        drawWarpedImages(source, target, sourceWarped, displ); 
    
    elseif ndims(source) == 3
        % prepare segmentations
        sourceSeg = padarray(volresize(nii2vol(sourceSegFile), newSrcSize, 'nearest'), 3*params.patchSize, 'both');
        targetSeg = padarray(volresize(nii2vol(targetSegFile), newTarSize, 'nearest'), 3*params.patchSize, 'both');

        sourceSegmWarped = volwarp(sourceSeg, displ, opts.warpDir, 'interpmethod', 'nearest');
        
        % visualize
        view3Dopt(source, target, sourceWarped, targetWarped, ...
            sourceSeg, targetSeg, sourceSegmWarped, ...
            displ{:});
    end
    
    % save segmentations 
    nonsegVolumes = struct('source', source, 'target', target, 'sourceWarped', sourceWarped, 'targetWarped', targetWarped);
    volumes = struct('sourceSeg', sourceSeg, 'targetSeg', targetSeg);
    save(sprintf(opts.savefile, 0, 0), 'volumes', 'displ', 'nonsegVolumes');
    
=======
    paths.output = OUTPUT_PATH;
    
    %% Carry out the registration
    register(paths, params, opts)    
>>>>>>> d9ffbee3317b343c8ff5e7bfad02b936e690a6fe
